/**
 * @license React
 * jest-react.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';

var Scheduler = require('scheduler/unstable_mock');

const assign = Object.assign;

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
const REACT_ELEMENT_TYPE = Symbol.for('react.element');
const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');

const isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
  return isArrayImpl(a);
}

let enqueueTaskImpl = null;
function enqueueTask(task) {
  if (enqueueTaskImpl === null) {
    try {
      // read require off the module object to get around the bundlers.
      // we don't want them to detect a require and bundle a Node polyfill.
      const requireString = ('require' + Math.random()).slice(0, 7);
      const nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's
      // version of setImmediate, bypassing fake timers if any.

      enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
    } catch (_err) {
      // we're in a browser
      // we can't use regular timers because they may still be faked
      // so we try MessageChannel+postMessage instead
      enqueueTaskImpl = function (callback) {

        const channel = new MessageChannel();
        channel.port1.onmessage = callback;
        channel.port2.postMessage(undefined);
      };
    }
  }

  return enqueueTaskImpl(task);
}

// This version of `act` is only used by our tests. Unlike the public version
function act(scope) {
  if (Scheduler.unstable_flushUntilNextPaint === undefined) {
    throw Error('This version of `act` requires a special mock build of Scheduler.');
  } // $FlowFixMe: _isMockFunction doesn't exist on function


  if (setTimeout._isMockFunction !== true) {
    throw Error("This version of `act` requires Jest's timer mocks " + '(i.e. jest.useFakeTimers).');
  }

  const unwind = () => {
  }; // TODO: This would be way simpler if 1) we required a promise to be
  // returned and 2) we could use async/await. Since it's only our used in
  // our test suite, we should be able to.


  try {
    const result = scope();

    if (typeof result === 'object' && result !== null && // $FlowFixMe[method-unbinding]
    typeof result.then === 'function') {
      const thenableResult = result;
      return {
        then(resolve, reject) {
          thenableResult.then(returnValue => {
            flushActWork(() => {
              unwind();
              resolve(returnValue);
            }, error => {
              unwind();
              reject(error);
            });
          }, error => {
            unwind();
            reject(error);
          });
        }

      };
    } else {
      const returnValue = result;

      try {
        // TODO: Let's not support non-async scopes at all in our tests. Need to
        // migrate existing tests.
        let didFlushWork;

        do {
          didFlushWork = Scheduler.unstable_flushAllWithoutAsserting();
        } while (didFlushWork);

        return {
          then(resolve, reject) {
            resolve(returnValue);
          }

        };
      } finally {
        unwind();
      }
    }
  } catch (error) {
    throw error;
  }
}

function flushActWork(resolve, reject) {
  if (Scheduler.unstable_hasPendingWork()) {
    try {
      Scheduler.unstable_flushUntilNextPaint();
    } catch (error) {
      reject(error);
    } // If Scheduler yields while there's still work, it's so that we can
    // unblock the main thread (e.g. for paint or for microtasks). Yield to
    // the main thread and continue in a new task.


    enqueueTask(() => flushActWork(resolve, reject));
    return;
  } // Once the scheduler queue is empty, run all the timers. The purpose of this
  // is to force any pending fallbacks to commit. The public version of act does
  // this with dev-only React runtime logic, but since our internal act needs to
  // work production builds of React, we have to cheat.
  // $FlowFixMe: Flow doesn't know about global Jest object


  jest.runOnlyPendingTimers();

  if (Scheduler.unstable_hasPendingWork()) {
    // Committing a fallback scheduled additional work. Continue flushing.
    flushActWork(resolve, reject);
    return;
  }

  resolve();
}

function captureAssertion(fn) {
  // Trick to use a Jest matcher inside another Jest matcher. `fn` contains an
  // assertion; if it throws, we capture the error and return it, so the stack
  // trace presented to the user points to the original assertion in the
  // test file.
  try {
    fn();
  } catch (error) {
    return {
      pass: false,
      message: () => error.message
    };
  }

  return {
    pass: true
  };
}

function assertYieldsWereCleared(root) {
  const Scheduler = root._Scheduler;
  const actualYields = Scheduler.unstable_clearYields();

  if (actualYields.length !== 0) {
    throw new Error('Log of yielded values is not empty. ' + 'Call expect(ReactTestRenderer).unstable_toHaveYielded(...) first.');
  }
}

function unstable_toMatchRenderedOutput(root, expectedJSX) {
  assertYieldsWereCleared(root);
  const actualJSON = root.toJSON();
  let actualJSX;

  if (actualJSON === null || typeof actualJSON === 'string') {
    actualJSX = actualJSON;
  } else if (isArray(actualJSON)) {
    if (actualJSON.length === 0) {
      actualJSX = null;
    } else if (actualJSON.length === 1) {
      actualJSX = jsonChildToJSXChild(actualJSON[0]);
    } else {
      const actualJSXChildren = jsonChildrenToJSXChildren(actualJSON);

      if (actualJSXChildren === null || typeof actualJSXChildren === 'string') {
        actualJSX = actualJSXChildren;
      } else {
        actualJSX = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: REACT_FRAGMENT_TYPE,
          key: null,
          ref: null,
          props: {
            children: actualJSXChildren
          },
          _owner: null,
          _store:  undefined
        };
      }
    }
  } else {
    actualJSX = jsonChildToJSXChild(actualJSON);
  }

  return captureAssertion(() => {
    expect(actualJSX).toEqual(expectedJSX);
  });
}

function jsonChildToJSXChild(jsonChild) {
  if (jsonChild === null || typeof jsonChild === 'string') {
    return jsonChild;
  } else {
    const jsxChildren = jsonChildrenToJSXChildren(jsonChild.children);
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: jsonChild.type,
      key: null,
      ref: null,
      props: jsxChildren === null ? jsonChild.props : assign({}, jsonChild.props, {
        children: jsxChildren
      }),
      _owner: null,
      _store:  undefined
    };
  }
}

function jsonChildrenToJSXChildren(jsonChildren) {
  if (jsonChildren !== null) {
    if (jsonChildren.length === 1) {
      return jsonChildToJSXChild(jsonChildren[0]);
    } else if (jsonChildren.length > 1) {
      const jsxChildren = [];
      let allJSXChildrenAreStrings = true;
      let jsxChildrenString = '';

      for (let i = 0; i < jsonChildren.length; i++) {
        const jsxChild = jsonChildToJSXChild(jsonChildren[i]);
        jsxChildren.push(jsxChild);

        if (allJSXChildrenAreStrings) {
          if (typeof jsxChild === 'string') {
            jsxChildrenString += jsxChild;
          } else if (jsxChild !== null) {
            allJSXChildrenAreStrings = false;
          }
        }
      }

      return allJSXChildrenAreStrings ? jsxChildrenString : jsxChildren;
    }
  }

  return null;
}

exports.act = act;
exports.unstable_toMatchRenderedOutput = unstable_toMatchRenderedOutput;
